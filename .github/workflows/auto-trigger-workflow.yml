import os
import re
import sys
from glob import glob
import json

class ScriptConverter:
    def __init__(self):
        self.github_repo = "Mikephie/AutomatedJS"
        
        # 默认值 - 当无法提取信息时使用
        self.defaults = {
            "desc": "模块",
            "category": "🔐APP",
            "author": "🅜ⓘ🅚ⓔ🅟ⓗ🅘ⓔ",
        }
        
        # 保存转换过程中的统计信息
        self.stats = {
            "success": 0,
            "failed": 0,
            "skipped": 0
        }
    
    def log(self, message, level="INFO"):
        """统一的日志输出函数"""
        print(f"[{level}] {message}")
    
    def extract_script_content(self, content):
        """提取注释块中的内容"""
        comment_match = re.search(r'/\*([\s\S]*?)\*/', content)
        if comment_match:
            return comment_match.group(1).strip()
        return content
    
    def extract_all_info(self, file_path):
        """从脚本文件中提取所有需要的信息"""
        try:
            with open(file_path, 'r', encoding='utf-8') as file:
                content = file.read()
            
            # 处理注释块
            content = self.extract_script_content(content)
            
            # 获取基本文件信息
            filename = os.path.basename(file_path)
            scriptname = os.path.splitext(filename)[0]
            
            # 解析脚本的完整结构
            script_info = self.parse_script(content, scriptname)
            
            return script_info
        except Exception as e:
            self.log(f"处理 {file_path} 时出错: {str(e)}", "ERROR")
            return None
    
    def parse_script(self, content, scriptname):
        """解析脚本完整结构，保留所有注释和原始格式"""
        # 初始化结果
        result = {
            "metadata": self.extract_metadata(content, scriptname),
            "rules": [],
            "rewrites": [],
            "scripts": [],
            "hostname": "",
            "filename": scriptname,
            "raw_content": content
        }
        
        # 提取各个部分的内容
        self.extract_sections(content, result)
        
        # 提取 hostname
        result["hostname"] = self.extract_hostname(content)
        
        return result
    
    def extract_sections(self, content, result):
        """提取所有节点，包括注释"""
        # 尝试提取 Loon 格式节点
        loon_sections = {
            "Rule": re.search(r'\[Rule\]([\s\S]*?)(?=\[|$)', content, re.IGNORECASE),
            "Rewrite": re.search(r'\[Rewrite\]([\s\S]*?)(?=\[|$)', content, re.IGNORECASE),
            "Script": re.search(r'\[Script\]([\s\S]*?)(?=\[|$)', content, re.IGNORECASE)
        }
        
        # 尝试提取 QX 格式节点
        qx_sections = {
            "filter_local": re.search(r'\[filter_local\]([\s\S]*?)(?=\[|$)', content, re.IGNORECASE),
            "rewrite_local": re.search(r'\[rewrite_local\]([\s\S]*?)(?=\[|$)', content, re.IGNORECASE)
        }
        
        # 处理 Loon 格式
        if loon_sections["Rule"] and loon_sections["Rule"].group(1):
            self.parse_section_with_comments(loon_sections["Rule"].group(1), result["rules"])
        
        if loon_sections["Rewrite"] and loon_sections["Rewrite"].group(1):
            self.parse_section_with_comments(loon_sections["Rewrite"].group(1), result["rewrites"])
        
        if loon_sections["Script"] and loon_sections["Script"].group(1):
            self.parse_section_with_comments(loon_sections["Script"].group(1), result["scripts"])
        
        # 如果没有找到 Loon 格式，尝试 QX 格式
        if not result["rules"] and qx_sections["filter_local"] and qx_sections["filter_local"].group(1):
            self.parse_qx_filter(qx_sections["filter_local"].group(1), result)
        
        if not (result["rewrites"] or result["scripts"]) and qx_sections["rewrite_local"] and qx_sections["rewrite_local"].group(1):
            self.parse_qx_rewrite(qx_sections["rewrite_local"].group(1), result)
    
    def parse_section_with_comments(self, section_content, target_array):
        """解析节点内容，保留注释"""
        lines = section_content.split('\n')
        current_comment = ""
        
        for line in lines:
            line = line.strip()
            if not line:
                continue
            
            if line.startswith('#'):
                # 收集注释
                current_comment = line
            else:
                # 处理内容行
                target_array.append({
                    "content": line,
                    "comment": current_comment
                })
                # 重置注释
                current_comment = ""
    
    def parse_qx_filter(self, filter_content, result):
        """解析 QX 过滤规则，转换为 Loon 格式"""
        lines = filter_content.split('\n')
        current_comment = ""
        
        for line in lines:
            line = line.strip()
            if not line:
                continue
            
            if line.startswith('#'):
                # 收集注释
                current_comment = line
            else:
                # 转换 QX 规则为 Loon 格式
                loon_rule = self.convert_qx_filter_to_loon(line)
                if loon_rule:
                    result["rules"].append({
                        "content": loon_rule,
                        "comment": current_comment
                    })
                # 重置注释
                current_comment = ""
    
    def parse_qx_rewrite(self, rewrite_content, result):
        """解析 QX 重写规则，分配到 Loon 的 Rewrite 和 Script 部分"""
        lines = rewrite_content.split('\n')
        current_comment = ""
        
        for line in lines:
            line = line.strip()
            if not line:
                continue
            
            if line.startswith('#'):
                # 收集注释
                current_comment = line
            elif ' url ' in line:
                parts = line.split(' url ')
                pattern = parts[0].strip()
                action = parts[1].strip()
                
                if action.startswith('reject'):
                    # reject 规则放入 Rewrite
                    result["rewrites"].append({
                        "content": f"{pattern} - {action}",
                        "comment": current_comment
                    })
                elif action.startswith('script-'):
                    # 脚本规则放入 Script
                    script_rule = self.convert_qx_script_to_loon(pattern, action, result["metadata"]["name"])
                    if script_rule:
                        result["scripts"].append({
                            "content": script_rule,
                            "comment": current_comment
                        })
                # 重置注释
                current_comment = ""
    
    def convert_qx_filter_to_loon(self, qx_filter):
        """将 QX 过滤规则转换为 Loon 格式"""
        # 处理 host
        if qx_filter.startswith('host,'):
            parts = qx_filter.split(',')
            if len(parts) >= 3:
                return f"DOMAIN,{parts[1]},{parts[2]}"
        
        # 处理 url-regex
        elif qx_filter.startswith('url-regex,'):
            parts = qx_filter.split(',')
            if len(parts) >= 3:
                return f"URL-REGEX,{parts[1]},{parts[2]}"
        
        # 默认直接返回
        return qx_filter
    
    def convert_qx_script_to_loon(self, pattern, qx_action, default_tag):
        """将 QX 脚本规则转换为 Loon 格式"""
        # 分解 QX 脚本规则
        script_parts = qx_action.split(' ')
        if len(script_parts) < 2:
            return None
        
        script_type = script_parts[0]
        script_path = script_parts[1]
        
        # 确定 HTTP 类型
        http_type = "http-response" if "response" in script_type else "http-request"
        
        # 确定是否需要 body
        requires_body = "true" if "body" in script_type else "false"
        
        # 提取脚本名作为标签
        tag = default_tag
        script_name = os.path.basename(script_path)
        script_name = os.path.splitext(script_name)[0]
        if script_name:
            tag = script_name
        
        # 返回 Loon 格式的脚本规则
        return f"{http_type} {pattern} script-path={script_path}, requires-body={requires_body}, timeout=60, tag={tag}"
    
    def extract_metadata(self, content, scriptname):
        """提取脚本元数据 (名称、描述、类别、作者、图标)"""
        metadata = {
            "name": scriptname,  # 默认使用脚本文件名
            "desc": self.defaults["desc"],
            "category": self.defaults["category"],
            "author": self.defaults["author"],
            "icon": f"https://raw.githubusercontent.com/Mikephie/icons/main/icon/{scriptname.lower()}.png"
        }
        
        # 从注释中提取元数据
        patterns = {
            "name": r'#!name\s*=\s*(.*?)[\n\r]',
            "desc": r'#!desc\s*=\s*(.*?)[\n\r]',
            "category": r'#!category\s*=\s*(.*?)[\n\r]',
            "author": r'#!author\s*=\s*(.*?)[\n\r]',
            "icon": r'#!icon\s*=\s*(.*?)[\n\r]'
        }
        
        for key, pattern in patterns.items():
            match = re.search(pattern, content, re.IGNORECASE)
            if match:
                metadata[key] = match.group(1).strip()
        
        # 尝试从内容猜测名称
        if metadata["name"] == scriptname:
            name_match = re.search(r'📜\s*(.*?)[\n\r]', content)
            if name_match:
                metadata["name"] = name_match.group(1).strip()
            else:
                # 尝试从内容中猜测名称
                for name_pattern in [r'彩云天气|caiyun|AXS Payment|([^\n]+脚本)']:
                    title_match = re.search(name_pattern, content, re.IGNORECASE)
                    if title_match:
                        metadata["name"] = title_match.group(0).strip()
                        break
        
        return metadata
    
    def extract_hostname(self, content):
        """提取 MITM 主机名"""
        # 从 [MITM] 或 [mitm] 部分提取
        mitm_match = re.search(r'\[(MITM|mitm)\]([\s\S]*?)(?=\[|$)', content)
        if mitm_match:
            hostname_match = re.search(r'hostname\s*=\s*([^\n\r]+)', mitm_match.group(2))
            if hostname_match:
                return hostname_match.group(1).strip()
        
        # 从整个内容中提取
        hostname_match = re.search(r'hostname\s*=\s*([^\n\r]+)', content)
        if hostname_match:
            return hostname_match.group(1).strip()
        
        # 尝试从规则中提取域名
        domain_match = re.search(r'https?:\/\/([^\/\s]+)', content)
        if domain_match:
            domain = domain_match.group(1).replace('\\', '')
            # 如果是子域名，转换为通配符形式
            if domain.count('.') > 1:
                parts = domain.split('.')
                return f"*.{parts[-2]}.{parts[-1]}"
            return domain
        
        return "example.com"
    
    def create_loon_config(self, info):
        """创建 Loon 配置"""
        metadata = info["metadata"]
        
        # 基本配置信息
        config = f"""#!name = {metadata["name"]}
#!desc = {metadata["desc"]}
#!category = {metadata["category"]}
#!author = {metadata["author"]}
#!icon = {metadata["icon"]}"""
        
        # 添加规则部分
        if info["rules"]:
            config += "\n\n[Rule]"
            last_comment = ""
            
            for rule in info["rules"]:
                # 添加注释（如果有新注释）
                if rule["comment"] and rule["comment"] != last_comment:
                    config += f"\n{rule['comment']}"
                    last_comment = rule["comment"]
                
                config += f"\n{rule['content']}"
        
        # 添加 Rewrite 部分
        if info["rewrites"]:
            config += "\n\n[Rewrite]"
            last_comment = ""
            
            for rewrite in info["rewrites"]:
                # 添加注释（如果有新注释）
                if rewrite["comment"] and rewrite["comment"] != last_comment:
                    config += f"\n{rewrite['comment']}"
                    last_comment = rewrite["comment"]
                
                config += f"\n{rewrite['content']}"
        
        # 添加 Script 部分
        if info["scripts"]:
            config += "\n\n[Script]"
            last_comment = ""
            
            for script in info["scripts"]:
                # 添加注释（如果有新注释）
                if script["comment"] and script["comment"] != last_comment:
                    config += f"\n{script['comment']}"
                    last_comment = script["comment"]
                
                config += f"\n{script['content']}"
        
        # 添加 MITM 部分
        config += f"\n\n[MITM]\nhostname = {info['hostname']}"
        
        return config
    
    def create_surge_config(self, info):
        """创建 Surge 配置"""
        metadata = info["metadata"]
        
        # 基本配置信息
        config = f"""#!name = {metadata["name"]}
#!desc = {metadata["desc"]}
#!category = {metadata["category"]}
#!author = {metadata["author"]}"""
        
        # 添加规则部分
        if info["rules"]:
            config += "\n\n[Rule]"
            last_comment = ""
            
            for rule in info["rules"]:
                # 添加注释
                if rule["comment"] and rule["comment"] != last_comment:
                    config += f"\n{rule['comment']}"
                    last_comment = rule["comment"]
                
                config += f"\n{rule['content']}"
        
        # 添加 Map Local 部分 (用于 reject 规则)
        reject_rules = [r for r in info["rewrites"] if ' - reject' in r["content"]]
        if reject_rules:
            config += "\n\n[Map Local]"
            last_comment = ""
            
            for rule in reject_rules:
                # 添加注释
                if rule["comment"] and rule["comment"] != last_comment:
                    config += f"\n{rule['comment']}"
                    last_comment = rule["comment"]
                
                # 提取模式和 reject 类型
                parts = rule["content"].split(' - ')
                pattern = parts[0]
                reject_type = parts[1] if len(parts) > 1 else "reject"
                
                # 设置 Map Local 参数
                data_type = "text"
                data = "{}"
                
                if "img" in reject_type:
                    data_type = "img"
                elif "array" in reject_type:
                    data = "[]"
                
                config += f"\n{pattern} data-type={data_type} data=\"{data}\" status-code=200"
        
        # 添加 Script 部分
        if info["scripts"]:
            config += "\n\n[Script]"
            last_comment = ""
            rule_counter = 0
            
            for script in info["scripts"]:
                # 添加注释
                if script["comment"] and script["comment"] != last_comment:
                    config += f"\n{script['comment']}"
                    last_comment = script["comment"]
                
                # 解析 Loon 脚本规则
                loon_script = script["content"]
                match = re.search(r'(http-(?:response|request))\s+([^\s]+)\s+script-path=([^,]+)', loon_script)
                
                if match:
                    http_type = match.group(1).replace('http-', '')
                    pattern = match.group(2)
                    script_path = match.group(3)
                    
                    # 确定是否需要 body
                    requires_body = "true" if "requires-body=true" in loon_script else "false"
                    
                    # 生成 Surge 规则名称
                    rule_name = info["metadata"]["name"] if rule_counter == 0 else f"{info['metadata']['name']}_{rule_counter+1}"
                    
                    config += f"\n{rule_name} = type=http-{http_type}, pattern={pattern}, script-path={script_path}, requires-body={requires_body}, max-size=-1, timeout=60"
                    
                    rule_counter += 1
        
        # 添加 MITM 部分
        config += f"\n\n[MITM]\nhostname = %APPEND% {info['hostname']}"
        
        return config
    
    def process_file(self, file_path):
        """处理单个文件"""
        try:
            # 提取文件名
            filename = os.path.basename(file_path)
            scriptname = os.path.splitext(filename)[0]
            
            self.log(f"正在处理: {filename}")
            
            # 提取信息
            info = self.extract_all_info(file_path)
            if not info:
                self.log(f"无法从 {filename} 提取信息，跳过", "WARN")
                self.stats["skipped"] += 1
                return False
            
            # 创建配置
            loon_config = self.create_loon_config(info)
            surge_config = self.create_surge_config(info)
            
            # 保存文件
            loon_path = f"Loon/{scriptname}.plugin"
            surge_path = f"Surge/{scriptname}.sgmodule"
            
            with open(loon_path, 'w', encoding='utf-8') as file:
                file.write(loon_config)
            
            with open(surge_path, 'w', encoding='utf-8') as file:
                file.write(surge_config)
            
            self.log(f"成功创建: {loon_path} 和 {surge_path}")
            self.stats["success"] += 1
            return True
            
        except Exception as e:
            self.log(f"处理 {file_path} 时出错: {str(e)}", "ERROR")
            self.stats["failed"] += 1
            return False
    
    def process_directory(self, directory, specific_file=None):
        """处理整个目录中的JS文件"""
        self.log(f"开始处理目录: {directory}")
        
        if specific_file:
            # 处理指定文件
            specific_path = os.path.join(directory, specific_file)
            if os.path.isfile(specific_path) and specific_path.endswith('.js'):
                self.process_file(specific_path)
            else:
                self.log(f"指定的文件不存在或不是JS文件: {specific_path}", "ERROR")
        else:
            # 处理所有文件
            js_files = glob(os.path.join(directory, "*.js"))
            if not js_files:
                self.log(f"目录中没有找到JS文件: {directory}", "WARN")
                return
            
            for file_path in js_files:
                self.process_file(file_path)
        
        # 输出统计信息
        self.log("\n转换统计:")
        self.log(f"成功: {self.stats['success']}")
        self.log(f"失败: {self.stats['failed']}")
        self.log(f"跳过: {self.stats['skipped']}")

def main():
    """主函数"""
    if len(sys.argv) < 2:
        print("用法: python enhanced_converter.py <qx_folder> [specific_file]")
        sys.exit(1)
    
    qx_folder = sys.argv[1]
    specific_file = sys.argv[2] if len(sys.argv) > 2 else None
    
    if not os.path.isdir(qx_folder):
        print(f"错误: {qx_folder} 不是有效目录")
        sys.exit(1)
    
    converter = ScriptConverter()
    converter.process_directory(qx_folder, specific_file)

if __name__ == "__main__":
    main()
