name: Enhanced Script Converter

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      specific_file:
        description: 'æŒ‡å®šè¦è½¬æ¢çš„è„šæœ¬æ–‡ä»¶è·¯å¾„ (ç•™ç©ºåˆ™å¤„ç†æ‰€æœ‰æ–‡ä»¶)'
        required: false
        default: ''

permissions:
  contents: write

jobs:
  convert-scripts:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Create output directories
        run: |
          mkdir -p Surge Loon
          
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: Determine QX folder
        id: folders
        run: |
          # è‡ªåŠ¨æ£€æµ‹ QuantumultX æ–‡ä»¶å¤¹ï¼Œæ”¯æŒå¤šç§å‘½åæ–¹å¼
          if [ -d "QuantumultX" ]; then
            echo "QX_FOLDER=QuantumultX" >> $GITHUB_OUTPUT
            echo "æ‰¾åˆ°æ–‡ä»¶å¤¹: QuantumultX"
          elif [ -d "quantumultx" ]; then
            echo "QX_FOLDER=quantumultx" >> $GITHUB_OUTPUT
            echo "æ‰¾åˆ°æ–‡ä»¶å¤¹: quantumultx"
          elif [ -d "quanx" ]; then
            echo "QX_FOLDER=quanx" >> $GITHUB_OUTPUT
            echo "æ‰¾åˆ°æ–‡ä»¶å¤¹: quanx"
          else
            echo "è­¦å‘Š: æœªæ‰¾åˆ° QuantumultX æ–‡ä»¶å¤¹ï¼Œä½¿ç”¨é»˜è®¤å€¼ QuantumultX"
            echo "QX_FOLDER=QuantumultX" >> $GITHUB_OUTPUT
            # åˆ›å»ºä¸€ä¸ªç›®å½•ä»¥é˜²æ­¢åç»­é”™è¯¯
            mkdir -p QuantumultX
          fi
      
      - name: Create enhanced converter script
        run: |
          cat > enhanced_converter.py << 'EOF'
          import os
          import re
          import sys
          from glob import glob
          import json
          
          class ScriptConverter:
              def __init__(self):
                  self.github_repo = "Mikephie/AutomatedJS"
                  
                  # é»˜è®¤å€¼ - å½“æ— æ³•æå–ä¿¡æ¯æ—¶ä½¿ç”¨
                  self.defaults = {
                      "desc": "æ¨¡å—",
                      "category": "ğŸ”APP",
                      "author": "ğŸ…œâ“˜ğŸ…šâ“”ğŸ…Ÿâ“—ğŸ…˜â“”",
                  }
                  
                  # ä¿å­˜è½¬æ¢è¿‡ç¨‹ä¸­çš„ç»Ÿè®¡ä¿¡æ¯
                  self.stats = {
                      "success": 0,
                      "failed": 0,
                      "skipped": 0
                  }
              
              def log(self, message, level="INFO"):
                  """ç»Ÿä¸€çš„æ—¥å¿—è¾“å‡ºå‡½æ•°"""
                  print(f"[{level}] {message}")
              
              def extract_all_info(self, file_path):
                  """ä»è„šæœ¬æ–‡ä»¶ä¸­æå–æ‰€æœ‰éœ€è¦çš„ä¿¡æ¯"""
                  try:
                      with open(file_path, 'r', encoding='utf-8') as file:
                          content = file.read()
                      
                      # è·å–åŸºæœ¬æ–‡ä»¶ä¿¡æ¯
                      filename = os.path.basename(file_path)
                      scriptname = os.path.splitext(filename)[0]
                      
                      # è·å–æ‰€æœ‰å…ƒæ•°æ®
                      metadata = self.extract_metadata(content, scriptname)
                      
                      # æå–ä¸»URLæ¨¡å¼
                      url_pattern = self.extract_url_pattern(content, scriptname)
                      
                      # æå–æ‰€æœ‰è¿‡æ»¤è§„åˆ™
                      reject_rules = self.extract_reject_rules(content)
                      filter_rules = self.extract_filter_rules(content)
                      
                      # æå– MITM ä¿¡æ¯
                      hostname = self.extract_hostname(content, scriptname)
                      
                      # æå–è„šæœ¬è·¯å¾„
                      script_path = self.get_script_path(content, scriptname)
                      
                      # æ„å»ºç»“æœä¿¡æ¯
                      return {
                          "filename": scriptname,
                          "metadata": metadata,
                          "url_pattern": url_pattern,
                          "hostname": hostname,
                          "script_path": script_path,
                          "reject_rules": reject_rules,
                          "filter_rules": filter_rules,
                          "raw_content": content  # ä¿å­˜åŸå§‹å†…å®¹ä»¥ä¾¿åç»­åˆ†æ
                      }
                  except Exception as e:
                      self.log(f"å¤„ç† {file_path} æ—¶å‡ºé”™: {str(e)}", "ERROR")
                      return None
              
              def extract_metadata(self, content, scriptname):
                  """æå–è„šæœ¬å…ƒæ•°æ® (åç§°ã€æè¿°ã€ç±»åˆ«ã€ä½œè€…ã€å›¾æ ‡)"""
                  metadata = {
                      "name": f"âœ¨ {scriptname} âœ¨",  # é»˜è®¤åç§°
                      "desc": self.defaults["desc"],
                      "category": self.defaults["category"],
                      "author": self.defaults["author"],
                      "icon": f"https://raw.githubusercontent.com/Mikephie/icons/main/icon/{scriptname.lower()}.png"
                  }
                  
                  # åç§°å¯èƒ½åœ¨ "ğŸ“œ" åå®šä¹‰
                  name_match = re.search(r'ğŸ“œ\s*(.*?)[\n\r]', content, re.DOTALL)
                  if name_match:
                      metadata["name"] = name_match.group(1).strip()
                  
                  # å°è¯•ç›´æ¥ä»æ³¨é‡Šä¸­æå–å…ƒæ•°æ®
                  patterns = {
                      "desc": r'#!desc\s*=\s*(.*?)[\n\r]',
                      "category": r'#!category\s*=\s*(.*?)[\n\r]',
                      "author": r'#!author\s*=\s*(.*?)[\n\r]',
                      "icon": r'#!icon\s*=\s*(.*?)[\n\r]',
                      "name": r'#!name\s*=\s*(.*?)[\n\r]'
                  }
                  
                  for key, pattern in patterns.items():
                      match = re.search(pattern, content)
                      if match:
                          metadata[key] = match.group(1).strip()
                  
                  return metadata
              
              def extract_url_pattern(self, content, default_name):
                  """æå–ä¸»è¦çš„URLåŒ¹é…æ¨¡å¼"""
                  # é¦–å…ˆæ£€æŸ¥ [rewrite_local] éƒ¨åˆ†
                  rewrite_section = re.search(r'\[rewrite_local\](.*?)(\[|$)', content, re.DOTALL | re.IGNORECASE)
                  if rewrite_section:
                      section_content = rewrite_section.group(1)
                      # å¯»æ‰¾ script-response-body è¡Œ
                      response_pattern = re.search(r'^([^\s]+)\s+url\s+script-response(-body|-header|-status)', section_content, re.MULTILINE)
                      if response_pattern:
                          return response_pattern.group(1).strip()
                  
                  # å¦‚æœæ‰¾ä¸åˆ°ï¼Œå°è¯•åœ¨æ•´ä¸ªæ–‡ä»¶ä¸­æŸ¥æ‰¾
                  response_pattern = re.search(r'([^\s]+)\s+url\s+script-response(-body|-header|-status)', content, re.MULTILINE)
                  if response_pattern:
                      return response_pattern.group(1).strip()
                  
                  return "^https?://example.com/"  # é»˜è®¤å€¼
              
              def extract_hostname(self, content, default_name):
                  """æå–MITMä¸»æœºå"""
                  # æ£€æŸ¥ [mitm] éƒ¨åˆ†
                  mitm_section = re.search(r'\[mitm\](.*?)(\[|$)', content, re.DOTALL | re.IGNORECASE)
                  if mitm_section:
                      section_content = mitm_section.group(1)
                      hostname_match = re.search(r'hostname\s*=\s*(.*?)[\n\r]', section_content)
                      if hostname_match:
                          return hostname_match.group(1).strip()
                  
                  # å¦‚æœæ‰¾ä¸åˆ°ï¼Œå°è¯•åœ¨æ•´ä¸ªæ–‡ä»¶ä¸­æŸ¥æ‰¾
                  hostname_match = re.search(r'hostname\s*=\s*(.*?)[\n\r]', content)
                  if hostname_match:
                      return hostname_match.group(1).strip()
                  
                  # æå–URLä¸»æœºéƒ¨åˆ†ä½œä¸ºé»˜è®¤ä¸»æœºå
                  return self.get_hostname_from_url_pattern(self.extract_url_pattern(content, default_name))
              
              def get_hostname_from_url_pattern(self, url_pattern):
                  """ä»URLæ¨¡å¼ä¸­æå–ä¸»æœºåéƒ¨åˆ†"""
                  try:
                      # ç§»é™¤æ­£åˆ™è¡¨è¾¾å¼çš„å‰ç¼€å’Œè½¬ä¹‰
                      cleaned_url = url_pattern.replace('^', '').replace('\\', '')
                      
                      # è·å–ä¸»æœºåéƒ¨åˆ† (http(s)://example.com/)
                      host_match = re.search(r'https?:\/\/([^\/]+)', cleaned_url)
                      if host_match:
                          return host_match.group(1)
                  except:
                      pass
                  
                  return "example.com"  # é»˜è®¤ä¸»æœºå
              
              def extract_reject_rules(self, content):
                  """æå–æ‹’ç»è§„åˆ™ (æ¥è‡ª rewrite_local éƒ¨åˆ†)"""
                  reject_rules = []
                  
                  # æ£€æŸ¥ [rewrite_local] éƒ¨åˆ†
                  rewrite_section = re.search(r'\[rewrite_local\](.*?)(\[|$)', content, re.DOTALL | re.IGNORECASE)
                  if rewrite_section:
                      section_content = rewrite_section.group(1)
                      lines = section_content.split('\n')
                      
                      for line in lines:
                          line = line.strip()
                          # è·³è¿‡ç©ºè¡Œå’Œæ³¨é‡Š
                          if not line or line.startswith('#'):
                              continue
                          
                          # æå–åŒ…å« reject ä½†ä¸åŒ…å« script çš„è¡Œ
                          if 'reject' in line.lower() and 'script' not in line.lower():
                              parts = line.split()
                              if len(parts) >= 2 and parts[0]:
                                  rule_pattern = parts[0]
                                  rule_action = 'reject'
                                  reject_rules.append({
                                      'pattern': rule_pattern, 
                                      'action': rule_action
                                  })
                  
                  return reject_rules
              
              def extract_filter_rules(self, content):
                  """æå–è¿‡æ»¤è§„åˆ™ (æ¥è‡ª filter_local éƒ¨åˆ†)"""
                  filter_rules = []
                  
                  # æ£€æŸ¥ [filter_local] éƒ¨åˆ†
                  filter_section = re.search(r'\[filter_local\](.*?)(\[|$)', content, re.DOTALL | re.IGNORECASE)
                  if filter_section:
                      section_content = filter_section.group(1)
                      lines = section_content.split('\n')
                      
                      for line in lines:
                          line = line.strip()
                          # è·³è¿‡ç©ºè¡Œå’Œæ³¨é‡Š
                          if not line or line.startswith('#'):
                              continue
                          
                          # å¤„ç† url-regex æ ¼å¼
                          url_regex_match = re.search(r'(url-regex),\s*(.*?)\s*,\s*(reject.*)', line, re.IGNORECASE)
                          if url_regex_match:
                              rule_type = url_regex_match.group(1).upper()
                              pattern = url_regex_match.group(2).strip()
                              action = url_regex_match.group(3).strip().upper()
                              filter_rules.append({
                                  'type': rule_type,
                                  'pattern': pattern,
                                  'action': action
                              })
                              continue
                          
                          # å¤„ç†å…¶ä»–æ ¼å¼
                          parts = line.split(',')
                          if len(parts) >= 3:
                              rule_type = parts[0].strip().upper()
                              pattern = parts[1].strip()
                              action = parts[2].strip().upper()
                              filter_rules.append({
                                  'type': rule_type,
                                  'pattern': pattern,
                                  'action': action
                              })
                  
                  return filter_rules
              
              def get_script_path(self, content, filename):
                  """è·å–è„šæœ¬è·¯å¾„"""
                  # å°è¯•ä»å†…å®¹ä¸­æå–è„šæœ¬è·¯å¾„
                  script_match = re.search(r'script-response-body\s+(https?:\/\/[^\s\n]+)', content)
                  if script_match:
                      full_path = script_match.group(1).strip()
                      return os.path.basename(full_path)
                  
                  # å¦‚æœæ²¡æœ‰æŒ‡å®šè·¯å¾„ï¼Œä½¿ç”¨æ–‡ä»¶å
                  return f"{filename}.js"
              
              def create_loon_config(self, info):
                  """åˆ›å»ºLooné…ç½®"""
                  metadata = info["metadata"]
                  
                  # åŸºæœ¬é…ç½®ä¿¡æ¯
                  config = f"""#!name = {metadata["name"]}
          #!desc = {metadata["desc"]}
          #!category = {metadata["category"]}
          #!author = {metadata["author"]}
          #!icon = {metadata["icon"]}
          """
                  
                  # æ·»åŠ è¿‡æ»¤è§„åˆ™
                  if info["filter_rules"]:
                      config += "\n[Rule]"
                      for rule in info["filter_rules"]:
                          config += f"\n{rule['type']},{rule['pattern']},{rule['action']}"
                  
                  # æ·»åŠ é‡å†™æ‹’ç»è§„åˆ™
                  if info["reject_rules"]:
                      config += "\n\n[Rewrite]"
                      for rule in info["reject_rules"]:
                          config += f"\n{rule['pattern']} reject"
                  
                  # æ·»åŠ è„šæœ¬éƒ¨åˆ†
                  script_path = f"https://raw.githubusercontent.com/{self.github_repo}/main/QuantumultX/{info['script_path']}"
                  config += f"\n\n[Script]\nhttp-response {info['url_pattern']} script-path={script_path}, requires-body=true, timeout=60, tag={info['filename']}"
                  
                  # æ·»åŠ MITMéƒ¨åˆ† (æœ€å)
                  config += f"\n\n[MITM]\nhostname = {info['hostname']}"
                  
                  return config
              
              def create_surge_config(self, info):
                  """åˆ›å»ºSurgeé…ç½®"""
                  metadata = info["metadata"]
                  
                  # åŸºæœ¬é…ç½®ä¿¡æ¯
                  config = f"""#!name = {metadata["name"]}
          #!desc = {metadata["desc"]}
          #!category = {metadata["category"]}
          #!author = {metadata["author"]}
          """
                  
                  # æ·»åŠ è¿‡æ»¤è§„åˆ™
                  if info["filter_rules"]:
                      config += "\n[Rule]"
                      for rule in info["filter_rules"]:
                          # Surgeä½¿ç”¨URL-REGEXè€Œä¸æ˜¯url-regex
                          rule_type = "URL-REGEX" if rule['type'].lower() == "url-regex" else rule['type']
                          config += f"\n{rule_type},{rule['pattern']},{rule['action']}"
                  
                  # æ·»åŠ é‡å†™æ‹’ç»è§„åˆ™
                  if info["reject_rules"]:
                      config += "\n\n[URL Rewrite]"
                      for rule in info["reject_rules"]:
                          config += f"\n{rule['pattern']} - reject"
                  
                  # æ·»åŠ è„šæœ¬éƒ¨åˆ†
                  script_path = f"https://raw.githubusercontent.com/{self.github_repo}/main/QuantumultX/{info['script_path']}"
                  config += f"\n\n[Script]\n{info['filename']} = type=http-response, pattern={info['url_pattern']}, script-path={script_path}, requires-body=true, max-size=-1, timeout=60"
                  
                  # æ·»åŠ MITMéƒ¨åˆ† (æœ€å)
                  config += f"\n\n[MITM]\nhostname = %APPEND% {info['hostname']}"
                  
                  return config
              
              def process_file(self, file_path):
                  """å¤„ç†å•ä¸ªæ–‡ä»¶"""
                  try:
                      # æå–æ–‡ä»¶å
                      filename = os.path.basename(file_path)
                      scriptname = os.path.splitext(filename)[0]
                      
                      self.log(f"æ­£åœ¨å¤„ç†: {filename}")
                      
                      # æå–ä¿¡æ¯
                      info = self.extract_all_info(file_path)
                      if not info:
                          self.log(f"æ— æ³•ä» {filename} æå–ä¿¡æ¯ï¼Œè·³è¿‡", "WARN")
                          self.stats["skipped"] += 1
                          return False
                      
                      # åˆ›å»ºé…ç½®
                      loon_config = self.create_loon_config(info)
                      surge_config = self.create_surge_config(info)
                      
                      # ä¿å­˜æ–‡ä»¶
                      loon_path = f"Loon/{scriptname}.plugin"
                      surge_path = f"Surge/{scriptname}.sgmodule"
                      
                      with open(loon_path, 'w', encoding='utf-8') as file:
                          file.write(loon_config)
                      
                      with open(surge_path, 'w', encoding='utf-8') as file:
                          file.write(surge_config)
                      
                      self.log(f"æˆåŠŸåˆ›å»º: {loon_path} å’Œ {surge_path}")
                      self.stats["success"] += 1
                      return True
                      
                  except Exception as e:
                      self.log(f"å¤„ç† {file_path} æ—¶å‡ºé”™: {str(e)}", "ERROR")
                      self.stats["failed"] += 1
                      return False
              
              def process_directory(self, directory, specific_file=None):
                  """å¤„ç†æ•´ä¸ªç›®å½•ä¸­çš„JSæ–‡ä»¶"""
                  self.log(f"å¼€å§‹å¤„ç†ç›®å½•: {directory}")
                  
                  if specific_file:
                      # å¤„ç†æŒ‡å®šæ–‡ä»¶
                      specific_path = os.path.join(directory, specific_file)
                      if os.path.isfile(specific_path) and specific_path.endswith('.js'):
                          self.process_file(specific_path)
                      else:
                          self.log(f"æŒ‡å®šçš„æ–‡ä»¶ä¸å­˜åœ¨æˆ–ä¸æ˜¯JSæ–‡ä»¶: {specific_path}", "ERROR")
                  else:
                      # å¤„ç†æ‰€æœ‰æ–‡ä»¶
                      js_files = glob(os.path.join(directory, "*.js"))
                      if not js_files:
                          self.log(f"ç›®å½•ä¸­æ²¡æœ‰æ‰¾åˆ°JSæ–‡ä»¶: {directory}", "WARN")
                          return
                      
                      for file_path in js_files:
                          self.process_file(file_path)
                  
                  # è¾“å‡ºç»Ÿè®¡ä¿¡æ¯
                  self.log("\nè½¬æ¢ç»Ÿè®¡:")
                  self.log(f"æˆåŠŸ: {self.stats['success']}")
                  self.log(f"å¤±è´¥: {self.stats['failed']}")
                  self.log(f"è·³è¿‡: {self.stats['skipped']}")
          
          def main():
              """ä¸»å‡½æ•°"""
              if len(sys.argv) < 2:
                  print("ç”¨æ³•: python enhanced_converter.py <qx_folder> [specific_file]")
                  sys.exit(1)
              
              qx_folder = sys.argv[1]
              specific_file = sys.argv[2] if len(sys.argv) > 2 else None
              
              if not os.path.isdir(qx_folder):
                  print(f"é”™è¯¯: {qx_folder} ä¸æ˜¯æœ‰æ•ˆç›®å½•")
                  sys.exit(1)
              
              converter = ScriptConverter()
              converter.process_directory(qx_folder, specific_file)
          
          if __name__ == "__main__":
              main()
          EOF
      
      - name: Run converter
        run: |
          QX_FOLDER="${{ steps.folders.outputs.QX_FOLDER }}"
          SPECIFIC_FILE="${{ github.event.inputs.specific_file }}"
          
          echo "===== å¼€å§‹è„šæœ¬è½¬æ¢ ====="
          echo "è„šæœ¬ç›®å½•: $QX_FOLDER"
          
          if [ -n "$SPECIFIC_FILE" ]; then
            echo "æŒ‡å®šè½¬æ¢æ–‡ä»¶: $SPECIFIC_FILE"
            python enhanced_converter.py "$QX_FOLDER" "$SPECIFIC_FILE"
          else
            echo "è½¬æ¢æ‰€æœ‰è„šæœ¬æ–‡ä»¶"
            python enhanced_converter.py "$QX_FOLDER"
          fi
      
      - name: Commit and push changes
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          
          # æ·»åŠ æ‰€æœ‰ç”Ÿæˆçš„é…ç½®æ–‡ä»¶
          git add Surge/ Loon/
          
          # æ£€æŸ¥æ˜¯å¦æœ‰æ–‡ä»¶å˜æ›´éœ€è¦æäº¤
          if git diff-index --quiet HEAD; then
            echo "æ²¡æœ‰æ–‡ä»¶å˜æ›´ï¼Œæ— éœ€æäº¤"
          else
            # æäº¤å¹¶æ¨é€
            git commit -m "è‡ªåŠ¨ç”Ÿæˆæ¨¡å—é…ç½® [$(date +'%Y-%m-%d %H:%M:%S')]"
            git push || echo "æ¨é€å¤±è´¥ï¼Œå¯èƒ½æ˜¯è¿œç¨‹ä»“åº“å˜åŒ–å¯¼è‡´"
          fi
