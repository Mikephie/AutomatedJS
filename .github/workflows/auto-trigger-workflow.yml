import os
import re
import sys
from glob import glob
import json

class ScriptConverter:
    def __init__(self):
        self.github_repo = "Mikephie/AutomatedJS"
        
        # é»˜è®¤å€¼ - å½“æ— æ³•æå–ä¿¡æ¯æ—¶ä½¿ç”¨
        self.defaults = {
            "desc": "æ¨¡å—",
            "category": "ğŸ”APP",
            "author": "ğŸ…œâ“˜ğŸ…šâ“”ğŸ…Ÿâ“—ğŸ…˜â“”",
        }
        
        # ä¿å­˜è½¬æ¢è¿‡ç¨‹ä¸­çš„ç»Ÿè®¡ä¿¡æ¯
        self.stats = {
            "success": 0,
            "failed": 0,
            "skipped": 0
        }
    
    def log(self, message, level="INFO"):
        """ç»Ÿä¸€çš„æ—¥å¿—è¾“å‡ºå‡½æ•°"""
        print(f"[{level}] {message}")
    
    def extract_script_content(self, content):
        """æå–æ³¨é‡Šå—ä¸­çš„å†…å®¹"""
        comment_match = re.search(r'/\*([\s\S]*?)\*/', content)
        if comment_match:
            return comment_match.group(1).strip()
        return content
    
    def extract_all_info(self, file_path):
        """ä»è„šæœ¬æ–‡ä»¶ä¸­æå–æ‰€æœ‰éœ€è¦çš„ä¿¡æ¯"""
        try:
            with open(file_path, 'r', encoding='utf-8') as file:
                content = file.read()
            
            # å¤„ç†æ³¨é‡Šå—
            content = self.extract_script_content(content)
            
            # è·å–åŸºæœ¬æ–‡ä»¶ä¿¡æ¯
            filename = os.path.basename(file_path)
            scriptname = os.path.splitext(filename)[0]
            
            # è§£æè„šæœ¬çš„å®Œæ•´ç»“æ„
            script_info = self.parse_script(content, scriptname)
            
            return script_info
        except Exception as e:
            self.log(f"å¤„ç† {file_path} æ—¶å‡ºé”™: {str(e)}", "ERROR")
            return None
    
    def parse_script(self, content, scriptname):
        """è§£æè„šæœ¬å®Œæ•´ç»“æ„ï¼Œä¿ç•™æ‰€æœ‰æ³¨é‡Šå’ŒåŸå§‹æ ¼å¼"""
        # åˆå§‹åŒ–ç»“æœ
        result = {
            "metadata": self.extract_metadata(content, scriptname),
            "rules": [],
            "rewrites": [],
            "scripts": [],
            "hostname": "",
            "filename": scriptname,
            "raw_content": content
        }
        
        # æå–å„ä¸ªéƒ¨åˆ†çš„å†…å®¹
        self.extract_sections(content, result)
        
        # æå– hostname
        result["hostname"] = self.extract_hostname(content)
        
        return result
    
    def extract_sections(self, content, result):
        """æå–æ‰€æœ‰èŠ‚ç‚¹ï¼ŒåŒ…æ‹¬æ³¨é‡Š"""
        # å°è¯•æå– Loon æ ¼å¼èŠ‚ç‚¹
        loon_sections = {
            "Rule": re.search(r'\[Rule\]([\s\S]*?)(?=\[|$)', content, re.IGNORECASE),
            "Rewrite": re.search(r'\[Rewrite\]([\s\S]*?)(?=\[|$)', content, re.IGNORECASE),
            "Script": re.search(r'\[Script\]([\s\S]*?)(?=\[|$)', content, re.IGNORECASE)
        }
        
        # å°è¯•æå– QX æ ¼å¼èŠ‚ç‚¹
        qx_sections = {
            "filter_local": re.search(r'\[filter_local\]([\s\S]*?)(?=\[|$)', content, re.IGNORECASE),
            "rewrite_local": re.search(r'\[rewrite_local\]([\s\S]*?)(?=\[|$)', content, re.IGNORECASE)
        }
        
        # å¤„ç† Loon æ ¼å¼
        if loon_sections["Rule"] and loon_sections["Rule"].group(1):
            self.parse_section_with_comments(loon_sections["Rule"].group(1), result["rules"])
        
        if loon_sections["Rewrite"] and loon_sections["Rewrite"].group(1):
            self.parse_section_with_comments(loon_sections["Rewrite"].group(1), result["rewrites"])
        
        if loon_sections["Script"] and loon_sections["Script"].group(1):
            self.parse_section_with_comments(loon_sections["Script"].group(1), result["scripts"])
        
        # å¦‚æœæ²¡æœ‰æ‰¾åˆ° Loon æ ¼å¼ï¼Œå°è¯• QX æ ¼å¼
        if not result["rules"] and qx_sections["filter_local"] and qx_sections["filter_local"].group(1):
            self.parse_qx_filter(qx_sections["filter_local"].group(1), result)
        
        if not (result["rewrites"] or result["scripts"]) and qx_sections["rewrite_local"] and qx_sections["rewrite_local"].group(1):
            self.parse_qx_rewrite(qx_sections["rewrite_local"].group(1), result)
    
    def parse_section_with_comments(self, section_content, target_array):
        """è§£æèŠ‚ç‚¹å†…å®¹ï¼Œä¿ç•™æ³¨é‡Š"""
        lines = section_content.split('\n')
        current_comment = ""
        
        for line in lines:
            line = line.strip()
            if not line:
                continue
            
            if line.startswith('#'):
                # æ”¶é›†æ³¨é‡Š
                current_comment = line
            else:
                # å¤„ç†å†…å®¹è¡Œ
                target_array.append({
                    "content": line,
                    "comment": current_comment
                })
                # é‡ç½®æ³¨é‡Š
                current_comment = ""
    
    def parse_qx_filter(self, filter_content, result):
        """è§£æ QX è¿‡æ»¤è§„åˆ™ï¼Œè½¬æ¢ä¸º Loon æ ¼å¼"""
        lines = filter_content.split('\n')
        current_comment = ""
        
        for line in lines:
            line = line.strip()
            if not line:
                continue
            
            if line.startswith('#'):
                # æ”¶é›†æ³¨é‡Š
                current_comment = line
            else:
                # è½¬æ¢ QX è§„åˆ™ä¸º Loon æ ¼å¼
                loon_rule = self.convert_qx_filter_to_loon(line)
                if loon_rule:
                    result["rules"].append({
                        "content": loon_rule,
                        "comment": current_comment
                    })
                # é‡ç½®æ³¨é‡Š
                current_comment = ""
    
    def parse_qx_rewrite(self, rewrite_content, result):
        """è§£æ QX é‡å†™è§„åˆ™ï¼Œåˆ†é…åˆ° Loon çš„ Rewrite å’Œ Script éƒ¨åˆ†"""
        lines = rewrite_content.split('\n')
        current_comment = ""
        
        for line in lines:
            line = line.strip()
            if not line:
                continue
            
            if line.startswith('#'):
                # æ”¶é›†æ³¨é‡Š
                current_comment = line
            elif ' url ' in line:
                parts = line.split(' url ')
                pattern = parts[0].strip()
                action = parts[1].strip()
                
                if action.startswith('reject'):
                    # reject è§„åˆ™æ”¾å…¥ Rewrite
                    result["rewrites"].append({
                        "content": f"{pattern} - {action}",
                        "comment": current_comment
                    })
                elif action.startswith('script-'):
                    # è„šæœ¬è§„åˆ™æ”¾å…¥ Script
                    script_rule = self.convert_qx_script_to_loon(pattern, action, result["metadata"]["name"])
                    if script_rule:
                        result["scripts"].append({
                            "content": script_rule,
                            "comment": current_comment
                        })
                # é‡ç½®æ³¨é‡Š
                current_comment = ""
    
    def convert_qx_filter_to_loon(self, qx_filter):
        """å°† QX è¿‡æ»¤è§„åˆ™è½¬æ¢ä¸º Loon æ ¼å¼"""
        # å¤„ç† host
        if qx_filter.startswith('host,'):
            parts = qx_filter.split(',')
            if len(parts) >= 3:
                return f"DOMAIN,{parts[1]},{parts[2]}"
        
        # å¤„ç† url-regex
        elif qx_filter.startswith('url-regex,'):
            parts = qx_filter.split(',')
            if len(parts) >= 3:
                return f"URL-REGEX,{parts[1]},{parts[2]}"
        
        # é»˜è®¤ç›´æ¥è¿”å›
        return qx_filter
    
    def convert_qx_script_to_loon(self, pattern, qx_action, default_tag):
        """å°† QX è„šæœ¬è§„åˆ™è½¬æ¢ä¸º Loon æ ¼å¼"""
        # åˆ†è§£ QX è„šæœ¬è§„åˆ™
        script_parts = qx_action.split(' ')
        if len(script_parts) < 2:
            return None
        
        script_type = script_parts[0]
        script_path = script_parts[1]
        
        # ç¡®å®š HTTP ç±»å‹
        http_type = "http-response" if "response" in script_type else "http-request"
        
        # ç¡®å®šæ˜¯å¦éœ€è¦ body
        requires_body = "true" if "body" in script_type else "false"
        
        # æå–è„šæœ¬åä½œä¸ºæ ‡ç­¾
        tag = default_tag
        script_name = os.path.basename(script_path)
        script_name = os.path.splitext(script_name)[0]
        if script_name:
            tag = script_name
        
        # è¿”å› Loon æ ¼å¼çš„è„šæœ¬è§„åˆ™
        return f"{http_type} {pattern} script-path={script_path}, requires-body={requires_body}, timeout=60, tag={tag}"
    
    def extract_metadata(self, content, scriptname):
        """æå–è„šæœ¬å…ƒæ•°æ® (åç§°ã€æè¿°ã€ç±»åˆ«ã€ä½œè€…ã€å›¾æ ‡)"""
        metadata = {
            "name": scriptname,  # é»˜è®¤ä½¿ç”¨è„šæœ¬æ–‡ä»¶å
            "desc": self.defaults["desc"],
            "category": self.defaults["category"],
            "author": self.defaults["author"],
            "icon": f"https://raw.githubusercontent.com/Mikephie/icons/main/icon/{scriptname.lower()}.png"
        }
        
        # ä»æ³¨é‡Šä¸­æå–å…ƒæ•°æ®
        patterns = {
            "name": r'#!name\s*=\s*(.*?)[\n\r]',
            "desc": r'#!desc\s*=\s*(.*?)[\n\r]',
            "category": r'#!category\s*=\s*(.*?)[\n\r]',
            "author": r'#!author\s*=\s*(.*?)[\n\r]',
            "icon": r'#!icon\s*=\s*(.*?)[\n\r]'
        }
        
        for key, pattern in patterns.items():
            match = re.search(pattern, content, re.IGNORECASE)
            if match:
                metadata[key] = match.group(1).strip()
        
        # å°è¯•ä»å†…å®¹çŒœæµ‹åç§°
        if metadata["name"] == scriptname:
            name_match = re.search(r'ğŸ“œ\s*(.*?)[\n\r]', content)
            if name_match:
                metadata["name"] = name_match.group(1).strip()
            else:
                # å°è¯•ä»å†…å®¹ä¸­çŒœæµ‹åç§°
                for name_pattern in [r'å½©äº‘å¤©æ°”|caiyun|AXS Payment|([^\n]+è„šæœ¬)']:
                    title_match = re.search(name_pattern, content, re.IGNORECASE)
                    if title_match:
                        metadata["name"] = title_match.group(0).strip()
                        break
        
        return metadata
    
    def extract_hostname(self, content):
        """æå– MITM ä¸»æœºå"""
        # ä» [MITM] æˆ– [mitm] éƒ¨åˆ†æå–
        mitm_match = re.search(r'\[(MITM|mitm)\]([\s\S]*?)(?=\[|$)', content)
        if mitm_match:
            hostname_match = re.search(r'hostname\s*=\s*([^\n\r]+)', mitm_match.group(2))
            if hostname_match:
                return hostname_match.group(1).strip()
        
        # ä»æ•´ä¸ªå†…å®¹ä¸­æå–
        hostname_match = re.search(r'hostname\s*=\s*([^\n\r]+)', content)
        if hostname_match:
            return hostname_match.group(1).strip()
        
        # å°è¯•ä»è§„åˆ™ä¸­æå–åŸŸå
        domain_match = re.search(r'https?:\/\/([^\/\s]+)', content)
        if domain_match:
            domain = domain_match.group(1).replace('\\', '')
            # å¦‚æœæ˜¯å­åŸŸåï¼Œè½¬æ¢ä¸ºé€šé…ç¬¦å½¢å¼
            if domain.count('.') > 1:
                parts = domain.split('.')
                return f"*.{parts[-2]}.{parts[-1]}"
            return domain
        
        return "example.com"
    
    def create_loon_config(self, info):
        """åˆ›å»º Loon é…ç½®"""
        metadata = info["metadata"]
        
        # åŸºæœ¬é…ç½®ä¿¡æ¯
        config = f"""#!name = {metadata["name"]}
#!desc = {metadata["desc"]}
#!category = {metadata["category"]}
#!author = {metadata["author"]}
#!icon = {metadata["icon"]}"""
        
        # æ·»åŠ è§„åˆ™éƒ¨åˆ†
        if info["rules"]:
            config += "\n\n[Rule]"
            last_comment = ""
            
            for rule in info["rules"]:
                # æ·»åŠ æ³¨é‡Šï¼ˆå¦‚æœæœ‰æ–°æ³¨é‡Šï¼‰
                if rule["comment"] and rule["comment"] != last_comment:
                    config += f"\n{rule['comment']}"
                    last_comment = rule["comment"]
                
                config += f"\n{rule['content']}"
        
        # æ·»åŠ  Rewrite éƒ¨åˆ†
        if info["rewrites"]:
            config += "\n\n[Rewrite]"
            last_comment = ""
            
            for rewrite in info["rewrites"]:
                # æ·»åŠ æ³¨é‡Šï¼ˆå¦‚æœæœ‰æ–°æ³¨é‡Šï¼‰
                if rewrite["comment"] and rewrite["comment"] != last_comment:
                    config += f"\n{rewrite['comment']}"
                    last_comment = rewrite["comment"]
                
                config += f"\n{rewrite['content']}"
        
        # æ·»åŠ  Script éƒ¨åˆ†
        if info["scripts"]:
            config += "\n\n[Script]"
            last_comment = ""
            
            for script in info["scripts"]:
                # æ·»åŠ æ³¨é‡Šï¼ˆå¦‚æœæœ‰æ–°æ³¨é‡Šï¼‰
                if script["comment"] and script["comment"] != last_comment:
                    config += f"\n{script['comment']}"
                    last_comment = script["comment"]
                
                config += f"\n{script['content']}"
        
        # æ·»åŠ  MITM éƒ¨åˆ†
        config += f"\n\n[MITM]\nhostname = {info['hostname']}"
        
        return config
    
    def create_surge_config(self, info):
        """åˆ›å»º Surge é…ç½®"""
        metadata = info["metadata"]
        
        # åŸºæœ¬é…ç½®ä¿¡æ¯
        config = f"""#!name = {metadata["name"]}
#!desc = {metadata["desc"]}
#!category = {metadata["category"]}
#!author = {metadata["author"]}"""
        
        # æ·»åŠ è§„åˆ™éƒ¨åˆ†
        if info["rules"]:
            config += "\n\n[Rule]"
            last_comment = ""
            
            for rule in info["rules"]:
                # æ·»åŠ æ³¨é‡Š
                if rule["comment"] and rule["comment"] != last_comment:
                    config += f"\n{rule['comment']}"
                    last_comment = rule["comment"]
                
                config += f"\n{rule['content']}"
        
        # æ·»åŠ  Map Local éƒ¨åˆ† (ç”¨äº reject è§„åˆ™)
        reject_rules = [r for r in info["rewrites"] if ' - reject' in r["content"]]
        if reject_rules:
            config += "\n\n[Map Local]"
            last_comment = ""
            
            for rule in reject_rules:
                # æ·»åŠ æ³¨é‡Š
                if rule["comment"] and rule["comment"] != last_comment:
                    config += f"\n{rule['comment']}"
                    last_comment = rule["comment"]
                
                # æå–æ¨¡å¼å’Œ reject ç±»å‹
                parts = rule["content"].split(' - ')
                pattern = parts[0]
                reject_type = parts[1] if len(parts) > 1 else "reject"
                
                # è®¾ç½® Map Local å‚æ•°
                data_type = "text"
                data = "{}"
                
                if "img" in reject_type:
                    data_type = "img"
                elif "array" in reject_type:
                    data = "[]"
                
                config += f"\n{pattern} data-type={data_type} data=\"{data}\" status-code=200"
        
        # æ·»åŠ  Script éƒ¨åˆ†
        if info["scripts"]:
            config += "\n\n[Script]"
            last_comment = ""
            rule_counter = 0
            
            for script in info["scripts"]:
                # æ·»åŠ æ³¨é‡Š
                if script["comment"] and script["comment"] != last_comment:
                    config += f"\n{script['comment']}"
                    last_comment = script["comment"]
                
                # è§£æ Loon è„šæœ¬è§„åˆ™
                loon_script = script["content"]
                match = re.search(r'(http-(?:response|request))\s+([^\s]+)\s+script-path=([^,]+)', loon_script)
                
                if match:
                    http_type = match.group(1).replace('http-', '')
                    pattern = match.group(2)
                    script_path = match.group(3)
                    
                    # ç¡®å®šæ˜¯å¦éœ€è¦ body
                    requires_body = "true" if "requires-body=true" in loon_script else "false"
                    
                    # ç”Ÿæˆ Surge è§„åˆ™åç§°
                    rule_name = info["metadata"]["name"] if rule_counter == 0 else f"{info['metadata']['name']}_{rule_counter+1}"
                    
                    config += f"\n{rule_name} = type=http-{http_type}, pattern={pattern}, script-path={script_path}, requires-body={requires_body}, max-size=-1, timeout=60"
                    
                    rule_counter += 1
        
        # æ·»åŠ  MITM éƒ¨åˆ†
        config += f"\n\n[MITM]\nhostname = %APPEND% {info['hostname']}"
        
        return config
    
    def process_file(self, file_path):
        """å¤„ç†å•ä¸ªæ–‡ä»¶"""
        try:
            # æå–æ–‡ä»¶å
            filename = os.path.basename(file_path)
            scriptname = os.path.splitext(filename)[0]
            
            self.log(f"æ­£åœ¨å¤„ç†: {filename}")
            
            # æå–ä¿¡æ¯
            info = self.extract_all_info(file_path)
            if not info:
                self.log(f"æ— æ³•ä» {filename} æå–ä¿¡æ¯ï¼Œè·³è¿‡", "WARN")
                self.stats["skipped"] += 1
                return False
            
            # åˆ›å»ºé…ç½®
            loon_config = self.create_loon_config(info)
            surge_config = self.create_surge_config(info)
            
            # ä¿å­˜æ–‡ä»¶
            loon_path = f"Loon/{scriptname}.plugin"
            surge_path = f"Surge/{scriptname}.sgmodule"
            
            with open(loon_path, 'w', encoding='utf-8') as file:
                file.write(loon_config)
            
            with open(surge_path, 'w', encoding='utf-8') as file:
                file.write(surge_config)
            
            self.log(f"æˆåŠŸåˆ›å»º: {loon_path} å’Œ {surge_path}")
            self.stats["success"] += 1
            return True
            
        except Exception as e:
            self.log(f"å¤„ç† {file_path} æ—¶å‡ºé”™: {str(e)}", "ERROR")
            self.stats["failed"] += 1
            return False
    
    def process_directory(self, directory, specific_file=None):
        """å¤„ç†æ•´ä¸ªç›®å½•ä¸­çš„JSæ–‡ä»¶"""
        self.log(f"å¼€å§‹å¤„ç†ç›®å½•: {directory}")
        
        if specific_file:
            # å¤„ç†æŒ‡å®šæ–‡ä»¶
            specific_path = os.path.join(directory, specific_file)
            if os.path.isfile(specific_path) and specific_path.endswith('.js'):
                self.process_file(specific_path)
            else:
                self.log(f"æŒ‡å®šçš„æ–‡ä»¶ä¸å­˜åœ¨æˆ–ä¸æ˜¯JSæ–‡ä»¶: {specific_path}", "ERROR")
        else:
            # å¤„ç†æ‰€æœ‰æ–‡ä»¶
            js_files = glob(os.path.join(directory, "*.js"))
            if not js_files:
                self.log(f"ç›®å½•ä¸­æ²¡æœ‰æ‰¾åˆ°JSæ–‡ä»¶: {directory}", "WARN")
                return
            
            for file_path in js_files:
                self.process_file(file_path)
        
        # è¾“å‡ºç»Ÿè®¡ä¿¡æ¯
        self.log("\nè½¬æ¢ç»Ÿè®¡:")
        self.log(f"æˆåŠŸ: {self.stats['success']}")
        self.log(f"å¤±è´¥: {self.stats['failed']}")
        self.log(f"è·³è¿‡: {self.stats['skipped']}")

def main():
    """ä¸»å‡½æ•°"""
    if len(sys.argv) < 2:
        print("ç”¨æ³•: python enhanced_converter.py <qx_folder> [specific_file]")
        sys.exit(1)
    
    qx_folder = sys.argv[1]
    specific_file = sys.argv[2] if len(sys.argv) > 2 else None
    
    if not os.path.isdir(qx_folder):
        print(f"é”™è¯¯: {qx_folder} ä¸æ˜¯æœ‰æ•ˆç›®å½•")
        sys.exit(1)
    
    converter = ScriptConverter()
    converter.process_directory(qx_folder, specific_file)

if __name__ == "__main__":
    main()
